# stepik_selenium_py
Конспект курса по селениум+питон

курс: https://stepik.org/course/575/syllabus


html:
Объекты (тэги) - обрамляяются скобками
открывающий тэг <>
закрывающий тэг </>

	у тэгов есть атрибуты, атрибуты указываются в тех же скобках что название тэга, например:
	<h1 id='test'> </h1>
	div name='test'> <div>


Селекторы CSS
https://www.w3schools.com/cssref/css_selectors.php - синтаксис и селекторы
https://habr.com/ru/company/otus/blog/350368 - описание на хабре


	для поиска по атрибуту id используется #test (поставить # перед искомым значением)
	для поиска по атрибуту class используется .test (поставить точку перед искомым значением)
	для поиска атриубутов, у котрых нет коротких команд поиска (как "#" для id или "." для названия тэга) можно использовать вариант [value="test"] - так ищем атрибут value со значением test

	если атрибут class имеет два значения class='pet dog', то его поиска можно осуществить через:
	.pet (находит все атрибуты class, в которых содержится значение pet)
	.dog (находит все атрибуты class, в которых содержится значение dog)
	.pet.dog (находит все атрибуты class, в которых содержится значение pet и dog (порядокн не важен))

	Так-же поддерживают фильтрацию [] и команду выбора всех элеметов *

	Составные селекторы:
		значения атрибутов пишутся без пробела, например: 
			#file[accept=".txt"] - находит элемент с атрибут id=file и одновременно атрибутом accept='.txt'
			[name="email"][type="text"] - находит элемент с указанном атрибутом name и одновременно указанным атрибутом type


Иерархические селекторы CSS:

	Элементы на любом уровне иерархии:
		селектор #testid .testclass - означает что мы ищем элемент с id=testid и его потомка (на любом уровне иерархии) со значением class=testclass
		Cимвол пробела значащий и указывает на иерархию, после пробела указываются потомки элементов, который идут до пробела

		без указания пробела селектор будет искать элемент, у которого одновременно значение id=testid и значение class=testclass
		таким образом "#testid .testclass" и "#testid.testclass" - разные селекторы

	Для использования дочерних элементов:
		#testid > div.testclass - символ ">" указывает что мы в дочерних элементах, элемента со значением id=testid мы изем элемент с тегом div и class=testclass (перед поском по классу перед точкой дополнительно указано название тега div, которое указывает в элементах с каким тегом нужно производить поиск)

		#posts > .item:nth-child(3) - находит третий по счету дочерний элемент со значением class=item для роительского элемента со значением id=posts
		сам псевдокласс nth-child(n) - находит n-ый по счету элемент по указанным парамтерам СТРОГО ВНУТРИ ОДНОГО РОДИТЕЛЯ


XPath:
https://www.w3schools.com/xml/xpath_syntax.asp - синтаксис xpath
https://habr.com/post/114772/ - описание на хабре

	XPath запрос всегда начинается с символа / или //;
	Символ "/" аналогичен символу ">" в CSS-селекторе, а символ "//" — пробелу;
	Перед ссылкой на названия атриубта указывается @ [@id="123"], [contains(@class, "navbar")];
	Поиск по значению регистрозависим;
	Можно использовать булевы операции и простую арифметику;

	/html/body/header - для поиска элемента header по указанному пути (запрос надо начинать с корня документа);
	//header для поиска элемента header, но запрос начинается с "//" это будет означать, что ищем всех потомков корневого элемента

	Символ [ ] — это команда фильтрации:
		//img[@id='bullet'] - фильтр по атрибуту, отберет элемент img с атрибутом id=bullet;
		//div[2] - фильтр по порядковому номеру, находит второй по порядку элемент div, ПОИСК СТРОГО ВНУТРИ ОДНОГО РОДИТЕЛЯ;
		//p[text()="Lenin cat"] - фильтр по тексту внутри элемента;
		//p[contains(text(), "cat")]  - фильтр по содержащемуся тексту, находит все элементы p, текст которых содержит "cat";
		//img[@name='bullet-cat' and @data-type='animal'] - фильтрация по логическому выражению. Поддерживаем and, or, not

	Символ * — команда выбора всех элементов:
		//div/*[@class="jumbotron-heading"] - отбирает все элмента, у которых родитель элемент div и установлено указанное значение атрибута class


selenium webdriver:

	Методы посика элементов на странице:
		ind_element(By.ID, value) — поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
		find_element(By.CSS_SELECTOR, value) — поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
		find_element(By.XPATH, value) — поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
		find_element(By.NAME, value) — поиск по атрибуту name элемента;
		find_element(By.TAG_NAME, value) — поиск элемента по названию тега элемента;
		find_element(By.CLASS_NAME, value) — поиск по значению атрибута class;
		find_element(By.LINK_TEXT, value) — поиск ссылки на странице по полному совпадению;
		find_element(By.PARTIAL_LINK_TEXT, value) — поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

		Поиск нескольких элеметов:
			find_elements(By.CSS_SELECTOR, value) - возвращает список найденных элементов, если элментов нет - пустой список

	Открытие браузера:
		browser.quit() - закрытие браузера (завершения процесса)
		browse.close() - закрытие ТЕКУЩЕГО окна браузера (если открыто >1 окна, закроется текущее, процесс будет продолжаться)
		Для закрытия браузера в конце программы, даже если в течении программы возникла ошибка можно использовать конструкции:
		1. with webdriver.Chrome(service=Service(ChromeDriverManager().install())) as browser:
		2. try:
			browser = webdriver.Chrome(service=Service(ChromeDriverManager().install()))
			browser.get("link")
		   finally:
		   	browser.quit()

    checkbox/radiobutton html:
		в разметке элементы чекбоксы и радиокнопки (чекбокс с возможность выбора только одного элемента) имеют тэг input и соответствующий атрибут type
		type='checkbox' - для чекбокса
		type="radio" - для радиокнопки
		у активных элементов чекбокс или радиокнопка установлен атрибут "checked"

		Сделать элемент активным можно через клик на соседний элементы с тэгом label, в котором содержится текст для указанной кнопки


	выпадающий список:
		У каждого элемента списка обычно есть уникальное значение атрибута value
		В списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка

		Варианты ответа задаются тегом option, значение value может отсутствовать. 
			Можно отмечать варианты с помощью обычного метода click(). Для этого сначала нужно применить метод click() для элемента с тегом select, чтобы список раскрылся, а затем кликнуть на нужный вариант ответа

		Получить все значения выпадающего списка можно через dropdown_values = Select(<веб элемент выпадающего списка>). Далее к полученному от Select() объекту можно применять методы поиска:
			dropdown_values.select_by_visible_text(value) - выбор по тексту, который содержит элемент выпадающего списка
         	dropdown_values.select_by_value(str(summed_red))  - так-же можно искать по атриубуту value элемента выпадающего списка
         	dropdown_values.select_by_index()  - или по индексу самого значения в списке элементов выпадающего списка

    Загрузка файлов на страницу, файлы:
    	Работает так-же через send_keys(<file_path>)
    	найти текущую директорию/текущий файл:
    		os.path.abspath(__file__) - выводит полный путь до исполняемого файла
			os.path.dirname(__file__) - выводит директорию, в которой находится исполняемый файл
			os.path.join(current_dir, 'file.txt') - для добавления файла (текстового в примере) в указанную директорию

	Alert:
		для переключения на всплывающее сообщение в браузере используется browser.switch_to.alert - возвращает элемент alert, с котормы можно взаимодействовать
		у всплывающих окон есть три типа - обычное (alert), с возможностью отказаться или согласиться (confirm) и с вводом (prompt)
		alert_elem.accept() - нажать OK в всплывающем сообщении
		alert_elem.text - получить текст из всплывающего сообщения
		alert_elem.accept() - подтвердить действие в всплывающем окне, если есть выбор согласиться или отказаться (тоже самое, что ОК)
		alert_elem.dismiss() - отказаться от действия в всплывающем окне, если есть выбор согласиться или отказаться (тоже самое, что нажать отмена)
		alert_elem.send_keys('value') - ввести значение в всплывающем окне, если есть возможность ввода

	Окна браузера:
		WebDriver может работать только с одной вкладкой браузера. При открытии новой вкладки WebDriver продолжит работать со старой вкладкой
		browser.switch_to.window(window_name) - для перехода на новую вкладку браузера, указав ее имя (window_name)
		browser.window_handles - список имен всех вкладок браузера, к которому можно обращаться по индексу (первая вкладка browser.window_handles[0])

	Ожидание появления элементов:
		Неявные ожидание Implicit wait:
			вместо явной команды на ожидания time.sleep() лучше использовать browser.implicitly_wait(5), который позволяет избежать холостого ожидания при time.spleep()
			метод implicitly_wait(5) будет ждать появления элемента 5 секунд и в течении этих 5 секунд каждые 500мс проверять наличие элемента.
			То есть в идеале мы получим элемент сразу, но если нет - в течении 5 секунд проверять его каждые 500мс (0.5 секунд).

			- Если элемент не был найден за отведенное время, то мы получим NoSuchElementException.
			- Если элемент был найден в момент поиска, но при последующем обращении к элементу DOM изменился, то получим StaleElementReferenceException. Например, мы нашли элемент Кнопка и через какое-то время решили выполнить с ним уже известный нам метод click. Если кнопка за это время была скрыта скриптом, то метод применять уже бесполезно — элемент "устарел" (stale) и мы увидим исключение.
			- Если элемент был найден в момент поиска, но сам элемент невидим (например, имеет нулевые размеры), и реальный пользователь не смог бы с ним взаимодействовать, то получим ElementNotVisibleException.

		Явные ожидания Explicit Waits:
			- реализуется через WebDriverWait и expected_conditions:
				from selenium.webdriver.support.ui import WebDriverWait
				from selenium.webdriver.support import expected_conditions as EC

			- # WebDriverWait(browser, wait_time) - принимает браузер, с котором происходит взаимодействие и время ожидания
        	  button = WebDriverWait(browser, 5).until(  # until принимает правило ожидания, например ожидания кликабельности элемента
              EC.element_to_be_clickable(vrf_btn)  # element_to_be_clickable(elem) возвращает True, когда element становится кликабельным, иначе False
        	  )
        	  # в итоге получается конструкция, когда мы находим элемент, устанавливаем то, что ждем от него, потом устанавливаем время ожидания	

            - если хотим наоборот проверить, что происходит обратное действие, например кнопка становится не клибальной можно использовать until_not вместо until

        	- Правила, которые можно реализовать в ожидании: (https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions)
        		title_is
				title_contains
				presence_of_element_located
				visibility_of_element_located
				visibility_of
				presence_of_all_elements_located
				text_to_be_present_in_element
				text_to_be_present_in_element_value
				frame_to_be_available_and_switch_to_it
				invisibility_of_element_located
				element_to_be_clickable
				staleness_of
				element_to_be_selected
				element_located_to_be_selected
				element_selection_state_to_be
				element_located_selection_state_to_be
				alert_is_present


	Другое:
		если нет кнопки submit или нужно сразу подтвердить ввод (нажать Enter) - используется один из следующих способов
			from selenium.webdriver.common.keys import Keys

			
			input_form.send_keys(Keys.RETURN)
			input_form.send_keys(Keys.ENTER)
	    	input_form.submit()

    	Атриубт объекта "text" для элемента позволяет получить текст, отображаемый в элементе (текст который видитпользователь) test.text == '123'

		метод get_attribute("checked") позволяет получить значение конкретного атрибута у конкретного элнемента test.get_attribute("checked") == '123'
		если в элементе, нет атрибута, указанного в методе get_attribute() - то возвращается None, если значение атрибута нет - то true

		выполнения JavaScript в селениум:
			метод execute_script (elem.execute_script("script")) позволяет выполнить джава скрипт на странице, например:
				button = browser.find_element(By.TAG_NAME, "button")
				browser.execute_script("return arguments[0].scrollIntoView(true);", button), где скрипт: "return arguments[0].scrollIntoView(true);"" - делает прокрутку, чтобы показать скрытый элемент

		 DOM-модель браузера (Document Object Model) — «объектная модель документа», интерфейс для доступа к HTML-содержимому сайта
